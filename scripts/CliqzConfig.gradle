buildscript {
    repositories {
        jcenter()
        google()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:3.4.1'
    }
}


import com.squareup.javawriter.JavaWriter
import groovy.json.JsonSlurper
import javax.lang.model.element.Modifier

apply plugin: CliqzPlugin

/**
 * Add a custom task to generate CLIQZ specific configuration file
 * Example structure for the config file:<br>
 * <pre>
 * {
 *   ".default": {
 *     "amazonSnsTopics": [ "<i>default_topic_arn</i>" ],
 *     "amazonApplicationARN": "...",
 *     "amazonAccountID": "...",
 *     "amazonIdentityPoolID": "...",
 *     "amazonUnauthRoleARN": "...",
 *     "amazonAuthRoleARN": "..."
 *   },
 *   "demo": {
 *     "amazonAccountID": "...",
 *     "amazonSnsTopics": [ "<i>demo_topic_arn</i>" ]
 *   },
 *   "full": {
 *     "amazonSnsTopics": [ "<i>full_topic_arn</i>" ]
 *   },
 *   "demoDebug": {
 *     ...
 *   },
 *   "demoRelease": {
 *     ...
 *   }
 * }
 * </pre>
 */
class CliqzPlugin implements Plugin<Project> {

    final static String CLIQZ_CONFIG_FILENAME = "CliqzConfig.java"
    final def configModifier = EnumSet.of(Modifier.FINAL, Modifier.PUBLIC,Modifier.STATIC)
    final static String CLIQZ_CONFIG_JSON = "cliqz-config.json"
    def logger

    void apply(Project project) {
        if (!project.plugins.hasPlugin('com.android.application')) {
            throw new IllegalArgumentException('Not an android app')
        }
        logger = project.logger
        File configFile = project.file(CLIQZ_CONFIG_JSON)
        if (!configFile.isFile()) {
            logger.warn("Missing configuration file: ${configFile}")
            return
        }

        JsonSlurper slurper = new JsonSlurper();
        def config = slurper.parse(configFile)
        project.afterEvaluate {
            project.android.applicationVariants.each { variant ->
                def buildConfig = variant.generateBuildConfigProvider.get()
                def compileProvider = variant.javaCompileProvider
                File sourceOutDir = buildConfig.sourceOutputDir
                String packageName = buildConfig.getBuildConfigPackageName()
                String taskName = buildConfig.name.replace('BuildConfig', 'CliqzConfig')
                def buildType = variant.buildType.name
                def flavorNames = variant.productFlavors.inject(new TreeSet()) { acc, value ->
                    acc += [ value.name as String, "${value.name}${buildType.capitalize()}" as String, buildType as String ]
                    acc
                }
                def variantConfig = config.findAll { flavorNames.contains(it.key) || it.key == '.default' }

                Task task = buildTask(project, taskName, variantConfig, packageName, sourceOutDir)
                task.mustRunAfter(buildConfig)
                compileProvider.get().dependsOn(task)
            }
        }
    }


    Task buildTask(Project project, String taskName, Map config, String packageName, File dstDir) {
        project.task(taskName) {
            doLast {
                def cfg = mergeConfig(config)
                File packageOutDir = new File(dstDir, packageName.replace('.' as char, File.separatorChar))
                def outFile = new File(packageOutDir, CLIQZ_CONFIG_FILENAME)
                outFile.withWriter { writer ->
                    JavaWriter javaWriter = new JavaWriter(writer)
                    javaWriter.emitJavadoc('Auto generated, do not edit')
                            .emitPackage(packageName)
                            .beginType('CliqzConfig', 'class', EnumSet.of(Modifier.PUBLIC, Modifier.FINAL))

                    cfg.each {
                        def ALLCAPS_KEY = it.key.replaceAll("([A-Z]+)", "_\$1").toUpperCase()
                        if (it.key == 'amazonSnsTopics') {
                            javaWriter.emitField('String[]', ALLCAPS_KEY, configModifier, "new String[] {${it.value.join(',')}}")
                        } else {
                            javaWriter.emitField('String', ALLCAPS_KEY, configModifier, it.value ? "\"${it.value}\"": 'null')
                        }
                    }
                    javaWriter.endType()
                }
            }
        }
    }

    Object mergeConfig(Map config) {
        def result = [
                amazonAccountID:null,
                amazonAuthRoleARN:null,
                amazonUnauthRoleARN:null,
                amazonIdentityPoolID:null,
                amazonApplicationARN:null,
                lookbackSdkToken:null
        ]
        def defaultConfig = config['.default']
        config.remove('.default')
        result.each { result[it.key] = mergeKey(config, defaultConfig, it.key) }
        result['amazonSnsTopics'] = mergeTopics(config, defaultConfig)
        result
    }

    List mergeTopics(Map config, Map defaultConfig) {
        def topics = config.inject(new TreeSet()) { acc, it ->
            def entries = it.value['amazonSnsTopics']
            if (entries) {
                acc += entries.collect { value -> "\"${value}\""}
            }
            acc
        }
        if (defaultConfig?.get('amazonSnsTopics')) {
            topics += defaultConfig?.get('amazonSnsTopics')?.collect { "\"${it}\"" }
        }
        topics.toList()
    }

    String mergeKey(Map config, Map defaultConfig, String key) {
        def result = config.inject(null) { result, val ->
            if (result != null) {
                logger.warn("Multiple ${key}")
            }
            result = val.value[key]
            result
        }
        result ? result : defaultConfig?.get(key)
    }
}
